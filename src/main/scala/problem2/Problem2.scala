package problem2

import scala.annotation.tailrec
import scala.collection.mutable._
/**
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * By starting with 1 and 2, the first 10 terms will be:
 *
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 *
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
 * find the sum of the even-valued terms
 */
object Problem2 extends App {

  var list = new ListBuffer[Int]
  list += (0,1)

  @tailrec
  def fibonacci(start: Int, max: Int): Unit = {

    val prevSum: Int = list(start-2) + list(start-1)
    if (prevSum < max) {
      list += prevSum
      fibonacci(start +1, max)
    }
  }

  fibonacci(2, 4000000)
  println(list.filter(e => e % 2 == 0).sum)

  var l2 = new ListBuffer[Int]
  l2 += (0,1)

  def fibonacciOptimised(start: Int, max: Int, int: ListBuffer[Int]): Unit = {

    @tailrec
    def loop(n: Int, m: Int, in: ListBuffer[Int]): ListBuffer[Int] = {
      val prevSum: Int = in(n - 2) + in(n - 1)
      if (prevSum < m) {
        in += prevSum
        loop(n + 1, m, in)
      } else in
    }
    loop(start, max, int)

  }


  fibonacciOptimised(2, 4000000, l2)

  println(l2.filter(e => e % 2 == 0).sum)

  // Method 3
  // Golden ratio is which tells nearest approximation of fibonnaci number
  def goldenRatio(n: Double): Double = {
    val phi: Double = 1.618034
    (math.pow(phi, n) - math.pow(1 - phi, n)) / math.sqrt(5)
  }

  val max = 4000000
  val initial: (List[Int], Int) = (List(1,0), 0)

  val result2 = Iterator.from(1)
    .takeWhile(goldenRatio(_) <= max)
    .foldLeft(initial)(
      (t,_) => {
        val (List(f, l), es) = t
        val fib = f + l
        (List(fib, f), if(fib % 2 == 0) es + fib else es)
      })._2

  println(result2)
}
